"""
Main Neural SDK client.

This module provides the primary interface for interacting with the Neural SDK.
It orchestrates all components and provides a simple, unified API for trading operations.
"""

import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Union

from .config import SDKConfig
from .exceptions import (
    ConfigurationError,
    ConnectionError,
    SDKError,
    TradingError,
    ValidationError,
)

logger = logging.getLogger(__name__)


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy."""

    action: str  # "BUY", "SELL", "HOLD"
    market_ticker: str
    side: str  # "YES" or "NO"
    confidence: float  # 0.0 to 1.0
    quantity: Optional[int] = None
    price_limit: Optional[float] = None
    reason: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        """Validate signal data."""
        if self.action not in ["BUY", "SELL", "HOLD"]:
            raise ValidationError(f"Invalid action: {self.action}")
        if self.side not in ["YES", "NO"]:
            raise ValidationError(f"Invalid side: {self.side}")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValidationError(
                f"Confidence must be between 0.0 and 1.0, got {self.confidence}"
            )


@dataclass
class MarketData:
    """Represents market data for a specific market."""

    ticker: str
    yes_price: float
    no_price: float
    yes_bid: Optional[float] = None
    yes_ask: Optional[float] = None
    no_bid: Optional[float] = None
    no_ask: Optional[float] = None
    volume: int = 0
    open_interest: int = 0
    last_update: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None

    @property
    def spread(self) -> Optional[float]:
        """Calculate the bid-ask spread."""
        if self.yes_ask and self.yes_bid:
            return self.yes_ask - self.yes_bid
        return None

    @property
    def implied_probability(self) -> float:
        """Calculate implied probability from prices."""
        return self.yes_price / (self.yes_price + self.no_price)


@dataclass
class TradeResult:
    """Result of a trade execution."""

    order_id: str
    market_ticker: str
    side: str
    quantity: int
    price: float
    status: str  # "FILLED", "PARTIAL", "REJECTED", "CANCELLED"
    timestamp: datetime
    fees: Optional[float] = None
    error_message: Optional[str] = None

    @property
    def total_cost(self) -> float:
        """Calculate total cost including fees."""
        cost = self.quantity * self.price
        if self.fees:
            cost += self.fees
        return cost


class NeuralSDK:
    """
    Main Neural SDK client.

    This is the primary interface for the Neural SDK. It provides
    a unified API for:
    - Market data streaming
    - Trading strategy deployment
    - Risk management
    - Portfolio monitoring
    - Agent orchestration

    Example:
        ```python
        from neural_sdk import NeuralSDK

        # Initialize SDK
        sdk = NeuralSDK.from_env()

        # Create and deploy a strategy
        @sdk.strategy
        async def my_strategy(market_data):
            if market_data.yes_price < 0.3:
                return sdk.create_signal("BUY", market_data.ticker)

        # Start trading
        await sdk.start_trading_system()
        ```
    """

    def __init__(self, config: SDKConfig):
        """
        Initialize the Neural SDK.

        Args:
            config: SDK configuration object

        Raises:
            ConfigurationError: If configuration is invalid
        """
        self.config = config
        self._validate_config()

        # Core components (to be initialized)
        self._agents = {}
        self._strategies = {}
        self._data_sources = {}
        self._is_running = False

        # Event handlers
        self._market_data_handlers: List[Callable] = []
        self._signal_handlers: List[Callable] = []
        self._trade_handlers: List[Callable] = []

        logger.info(f"Neural SDK initialized for {config.environment} environment")

    def _validate_config(self):
        """Validate SDK configuration."""
        if not self.config.api_key_id and self.config.environment != "development":
            raise ConfigurationError(
                "API key required for non-development environments"
            )

        if self.config.trading.enable_live_trading and not self.config.api_secret:
            raise ConfigurationError("API secret required for live trading")

    @classmethod
    def from_env(cls, prefix: str = "NEURAL_") -> "NeuralSDK":
        """
        Create SDK instance from environment variables.

        Args:
            prefix: Environment variable prefix

        Returns:
            Configured SDK instance
        """
        config = SDKConfig.from_env(prefix)
        return cls(config)

    @classmethod
    def from_config_file(cls, file_path: str) -> "NeuralSDK":
        """
        Create SDK instance from configuration file.

        Args:
            file_path: Path to YAML configuration file

        Returns:
            Configured SDK instance
        """
        config = SDKConfig.from_file(file_path)
        return cls(config)

    def create_signal(
        self,
        action: str,
        market_ticker: str,
        side: str = "YES",
        confidence: float = 0.5,
        quantity: Optional[int] = None,
        price_limit: Optional[float] = None,
        reason: Optional[str] = None,
        **metadata,
    ) -> TradingSignal:
        """
        Create a trading signal.

        Args:
            action: Trading action ("BUY", "SELL", "HOLD")
            market_ticker: Market ticker symbol
            side: Market side ("YES" or "NO")
            confidence: Signal confidence (0.0 to 1.0)
            quantity: Order quantity
            price_limit: Price limit for the order
            reason: Reason for the signal
            **metadata: Additional metadata

        Returns:
            TradingSignal object
        """
        if quantity is None:
            quantity = self.config.trading.default_quantity

        return TradingSignal(
            action=action,
            market_ticker=market_ticker,
            side=side,
            confidence=confidence,
            quantity=quantity,
            price_limit=price_limit,
            reason=reason,
            metadata=metadata or {},
        )

    def strategy(self, func: Callable) -> Callable:
        """
        Decorator to register a trading strategy.

        Args:
            func: Strategy function that takes market data and returns signals

        Returns:
            Decorated strategy function

        Example:
            ```python
            @sdk.strategy
            async def arbitrage_strategy(market_data):
                if market_data.yes_price + market_data.no_price < 0.98:
                    return sdk.create_signal("BUY", market_data.ticker)
            ```
        """
        strategy_name = func.__name__
        self._strategies[strategy_name] = func

        logger.info(f"Registered strategy: {strategy_name}")
        return func

    def on_market_data(self, func: Callable) -> Callable:
        """
        Decorator to register market data handler.

        Args:
            func: Handler function that processes market data

        Returns:
            Decorated handler function
        """
        self._market_data_handlers.append(func)
        return func

    def on_signal(self, func: Callable) -> Callable:
        """
        Decorator to register signal handler.

        Args:
            func: Handler function that processes trading signals

        Returns:
            Decorated handler function
        """
        self._signal_handlers.append(func)
        return func

    def on_trade(self, func: Callable) -> Callable:
        """
        Decorator to register trade handler.

        Args:
            func: Handler function that processes trade results

        Returns:
            Decorated handler function
        """
        self._trade_handlers.append(func)
        return func

    async def start_trading_system(self) -> None:
        """
        Start the complete trading system.

        This initializes all components:
        - Data sources and streaming
        - Agent orchestration
        - Strategy execution
        - Risk management
        - Monitoring

        Raises:
            SDKError: If system fails to start
        """
        if self._is_running:
            logger.warning("Trading system already running")
            return

        try:
            logger.info("Starting Neural Trading System...")

            # Initialize core components
            await self._initialize_data_sources()
            await self._initialize_agents()
            await self._initialize_monitoring()

            self._is_running = True
            logger.info("✅ Neural Trading System started successfully")

            # Start main event loop
            await self._run_trading_loop()

        except Exception as e:
            logger.error(f"Failed to start trading system: {e}")
            await self.stop_trading_system()
            raise SDKError(f"Failed to start trading system: {e}") from e

    async def stop_trading_system(self) -> None:
        """
        Stop the trading system gracefully.

        This shuts down all components in the correct order.
        """
        if not self._is_running:
            return

        logger.info("Stopping Neural Trading System...")

        try:
            # Stop components in reverse order
            await self._shutdown_monitoring()
            await self._shutdown_agents()
            await self._shutdown_data_sources()

            self._is_running = False
            logger.info("✅ Neural Trading System stopped")

        except Exception as e:
            logger.error(f"Error during shutdown: {e}")
            raise SDKError(f"Error during system shutdown: {e}") from e

    async def _initialize_data_sources(self) -> None:
        """Initialize data sources and streaming."""
        logger.info("Initializing data sources...")

        # Initialize Redis connection for pub/sub
        # Initialize market data streams
        # Initialize ESPN data streams
        # Initialize other data sources based on config

        logger.info("✅ Data sources initialized")

    async def _initialize_agents(self) -> None:
        """Initialize and start agents."""
        logger.info("Initializing agents...")

        # TODO: Initialize trading agents if using agent-based architecture
        # This is optional - the SDK can work without agents using just strategies
        # 
        # Example agent initialization:
        # self._agents['data_coordinator'] = DataCoordinatorAgent(self.config)
        # self._agents['portfolio_monitor'] = PortfolioMonitorAgent(self.config)
        # self._agents['risk_manager'] = RiskManagerAgent(self.config)
        # 
        # for name, agent in self._agents.items():
        #     await agent.start()
        #     logger.info(f"Started {name} agent")

        logger.info("✅ Agents initialized (using strategy-based approach)")

    async def _initialize_monitoring(self) -> None:
        """Initialize monitoring and metrics."""
        if self.config.enable_monitoring:
            logger.info("Initializing monitoring...")

            # Initialize metrics collection
            # Initialize health checks
            # Initialize logging

            logger.info("✅ Monitoring initialized")

    async def _shutdown_data_sources(self) -> None:
        """Shutdown data sources."""
        logger.info("Shutting down data sources...")

        # Close all data source connections
        # Stop streaming threads/tasks

        logger.info("✅ Data sources shut down")

    async def _shutdown_agents(self) -> None:
        """Shutdown agents."""
        logger.info("Shutting down agents...")

        # Stop all agents
        # Close agent connections

        logger.info("✅ Agents shut down")

    async def _shutdown_monitoring(self) -> None:
        """Shutdown monitoring."""
        if self.config.enable_monitoring:
            logger.info("Shutting down monitoring...")

            # Stop metrics collection
            # Close monitoring connections

            logger.info("✅ Monitoring shut down")

    async def _run_trading_loop(self) -> None:
        """Main trading system event loop."""
        logger.info("Starting trading event loop...")

        try:
            while self._is_running:
                # Process market data
                await self._process_market_data()

                # Execute strategies
                await self._execute_strategies()

                # Process signals
                await self._process_signals()

                # Monitor portfolio
                await self._monitor_portfolio()

                # Brief pause to prevent busy waiting
                await asyncio.sleep(0.1)

        except asyncio.CancelledError:
            logger.info("Trading loop cancelled")
            raise
        except Exception as e:
            logger.error(f"Error in trading loop: {e}")
            raise

    async def _process_market_data(self) -> None:
        """Process incoming market data."""
        # Get market data from sources
        # Call market data handlers
        # Update internal market data cache

        for handler in self._market_data_handlers:
            try:
                # Call handler with market data
                pass
            except Exception as e:
                logger.error(f"Error in market data handler: {e}")

    async def _execute_strategies(self) -> None:
        """Execute registered trading strategies."""
        # Get current market data
        # Execute each strategy
        # Collect generated signals

        for strategy_name, strategy_func in self._strategies.items():
            try:
                # Execute strategy and collect signals
                pass
            except Exception as e:
                logger.error(f"Error executing strategy {strategy_name}: {e}")

    async def _process_signals(self) -> None:
        """Process trading signals."""
        # Validate signals
        # Apply risk management
        # Execute trades if approved
        # Call signal handlers

        for handler in self._signal_handlers:
            try:
                # Call handler with signals
                pass
            except Exception as e:
                logger.error(f"Error in signal handler: {e}")

    async def _monitor_portfolio(self) -> None:
        """Monitor portfolio and risk metrics."""
        # Update portfolio positions
        # Check risk limits
        # Generate risk alerts if needed
        # Update performance metrics

        pass

    async def get_market_data(self, ticker: str) -> Optional[MarketData]:
        """
        Get current market data for a specific ticker.

        Args:
            ticker: Market ticker symbol

        Returns:
            MarketData object or None if not found
        """
        # TODO: Implement market data fetching from data sources
        # This should query the unified stream manager or Kalshi client
        # Example implementation:
        # if self.stream_manager:
        #     return await self.stream_manager.get_market_context(ticker)
        # return None
        return None  # Placeholder - implement in your integration

    async def execute_signal(self, signal: TradingSignal) -> TradeResult:
        """
        Execute a trading signal.

        Args:
            signal: Trading signal to execute

        Returns:
            TradeResult with execution details

        Raises:
            TradingError: If trade execution fails
        """
        # TODO: Implement trade execution
        # This should:
        # 1. Validate signal against risk limits
        # 2. Check available capital
        # 3. Execute trade via Kalshi API
        # 4. Return TradeResult with execution details
        #
        # Example implementation:
        # if self.config.trading.enable_paper_trading:
        #     return await self._execute_paper_trade(signal)
        # else:
        #     return await self._execute_live_trade(signal)
        
        raise NotImplementedError("Trade execution not yet implemented - override in your implementation")

    async def get_portfolio_status(self) -> Dict[str, Any]:
        """
        Get current portfolio status and metrics.

        Returns:
            Dictionary with portfolio information
        """
        return {
            "total_value": 0.0,
            "cash_balance": 0.0,
            "positions": [],
            "daily_pnl": 0.0,
            "total_pnl": 0.0,
            "risk_metrics": {},
        }

    def get_system_status(self) -> Dict[str, Any]:
        """
        Get overall system status.

        Returns:
            Dictionary with system status information
        """
        return {
            "is_running": self._is_running,
            "environment": self.config.environment,
            "data_sources_connected": len(self._data_sources),
            "agents_active": len(self._agents),
            "strategies_loaded": len(self._strategies),
            "last_update": datetime.utcnow().isoformat(),
        }

    async def health_check(self) -> Dict[str, Any]:
        """
        Perform comprehensive health check.

        Returns:
            Dictionary with health check results
        """
        health = {
            "overall": "healthy",
            "components": {},
            "timestamp": datetime.utcnow().isoformat(),
        }

        # Check data sources
        health["components"]["data_sources"] = "healthy"  # Placeholder

        # Check agents
        health["components"]["agents"] = "healthy"  # Placeholder

        # Check trading
        health["components"]["trading"] = "healthy"  # Placeholder

        # Determine overall health
        component_statuses = health["components"].values()
        if "unhealthy" in component_statuses:
            health["overall"] = "unhealthy"
        elif "degraded" in component_statuses:
            health["overall"] = "degraded"

        return health

    def __repr__(self) -> str:
        """String representation of the SDK."""
        return f"NeuralSDK(environment={self.config.environment}, running={self._is_running})"
