"""
Main Neural SDK client.

This module provides the primary interface for interacting with the Neural SDK.
It orchestrates all components and provides a simple, unified API for trading operations.
"""

import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional

from .config import SDKConfig
from .exceptions import (
    ConfigurationError,
    SDKError,
    ValidationError,
)

logger = logging.getLogger(__name__)


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy."""

    action: str  # "BUY", "SELL", "HOLD"
    market_ticker: str
    side: str  # "YES" or "NO"
    confidence: float  # 0.0 to 1.0
    quantity: Optional[int] = None
    price_limit: Optional[float] = None
    reason: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        """Validate signal data."""
        if self.action not in ["BUY", "SELL", "HOLD"]:
            raise ValidationError(f"Invalid action: {self.action}")
        if self.side not in ["YES", "NO"]:
            raise ValidationError(f"Invalid side: {self.side}")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValidationError(
                f"Confidence must be between 0.0 and 1.0, got {self.confidence}"
            )


@dataclass
class MarketData:
    """Represents market data for a specific market."""

    ticker: str
    yes_price: float
    no_price: float
    yes_bid: Optional[float] = None
    yes_ask: Optional[float] = None
    no_bid: Optional[float] = None
    no_ask: Optional[float] = None
    volume: int = 0
    open_interest: int = 0
    last_update: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None

    @property
    def spread(self) -> Optional[float]:
        """Calculate the bid-ask spread."""
        if self.yes_ask and self.yes_bid:
            return self.yes_ask - self.yes_bid
        return None

    @property
    def implied_probability(self) -> float:
        """Calculate implied probability from prices."""
        return self.yes_price / (self.yes_price + self.no_price)


@dataclass
class TradeResult:
    """Result of a trade execution."""

    order_id: str
    market_ticker: str
    side: str
    quantity: int
    price: float
    status: str  # "FILLED", "PARTIAL", "REJECTED", "CANCELLED"
    timestamp: datetime
    fees: Optional[float] = None
    error_message: Optional[str] = None

    @property
    def total_cost(self) -> float:
        """Calculate total cost including fees."""
        cost = self.quantity * self.price
        if self.fees:
            cost += self.fees
        return cost


@dataclass
class Position:
    """Represents a market position in the portfolio."""

    ticker: str
    position: int  # Number of shares
    market_exposure: float  # Total exposure in dollars
    total_traded: float  # Total amount traded
    realized_pnl: float  # Realized P&L
    fees_paid: float  # Total fees paid
    resting_orders_count: int = 0  # Active orders for this market
    last_updated: Optional[datetime] = None

    @property
    def avg_price(self) -> float:
        """Calculate average price per share."""
        if self.position > 0:
            return self.market_exposure / self.position
        return 0.0

    @property
    def market_name(self) -> str:
        """Get human-readable market name from ticker."""
        # Parse common ticker patterns
        if 'PHIABROWN11' in self.ticker:
            return "A.J. Brown First TD (PHI)"
        elif 'DALCLAMB88' in self.ticker:
            return "CeeDee Lamb First TD (DAL)" 
        elif 'PHIJHURTS1' in self.ticker:
            return "Jalen Hurts First TD (PHI)"
        elif 'PHISBARKLEY26' in self.ticker:
            return "Saquon Barkley First TD (PHI)"
        elif 'KXNFLGAME' in self.ticker and 'PHI' in self.ticker:
            return "Eagles Win Game"
        elif 'KXNFLGAME' in self.ticker and 'DAL' in self.ticker:
            return "Cowboys Win Game"
        elif 'KXNFL' in self.ticker:
            return "NFL Market"
        return self.ticker


@dataclass
class Order:
    """Represents a trading order."""

    order_id: str
    market_ticker: str
    side: str  # "YES" or "NO"
    action: str  # "BUY" or "SELL"
    quantity: int
    price: float
    status: str  # "FILLED", "PARTIAL", "PENDING", "CANCELLED", "REJECTED"
    created_time: datetime
    filled_quantity: int = 0
    remaining_quantity: Optional[int] = None
    fees: Optional[float] = None
    error_message: Optional[str] = None

    @property
    def is_active(self) -> bool:
        """Check if order is still active."""
        return self.status in ["PENDING", "PARTIAL"]

    @property
    def total_cost(self) -> float:
        """Calculate total cost of the order."""
        cost = self.filled_quantity * self.price
        if self.fees:
            cost += self.fees
        return cost

    @property
    def fill_percentage(self) -> float:
        """Calculate fill percentage."""
        if self.quantity > 0:
            return (self.filled_quantity / self.quantity) * 100
        return 0.0


@dataclass
class Portfolio:
    """Represents overall portfolio summary."""

    balance: float  # Available cash balance
    total_value: float  # Total portfolio value
    positions: List[Position]
    daily_pnl: float = 0.0
    total_pnl: float = 0.0
    total_fees_paid: float = 0.0
    active_orders: int = 0
    last_updated: Optional[datetime] = None

    @property
    def total_exposure(self) -> float:
        """Calculate total market exposure across all positions."""
        return sum(pos.market_exposure for pos in self.positions)

    @property
    def position_count(self) -> int:
        """Get number of active positions."""
        return len([pos for pos in self.positions if pos.position > 0])

    @property
    def largest_position(self) -> Optional[Position]:
        """Get the largest position by exposure."""
        if not self.positions:
            return None
        return max(self.positions, key=lambda p: p.market_exposure)

    def get_position_by_ticker(self, ticker: str) -> Optional[Position]:
        """Get position for a specific ticker."""
        for position in self.positions:
            if position.ticker == ticker:
                return position
        return None


class NeuralSDK:
    """
    Main Neural SDK client.

    This is the primary interface for the Neural SDK. It provides
    a unified API for:
    - Market data streaming
    - Trading strategy deployment
    - Risk management
    - Portfolio monitoring
    - Agent orchestration

    Example:
        ```python
        from neural_sdk import NeuralSDK

        # Initialize SDK
        sdk = NeuralSDK.from_env()

        # Create and deploy a strategy
        @sdk.strategy
        async def my_strategy(market_data):
            if market_data.yes_price < 0.3:
                return sdk.create_signal("BUY", market_data.ticker)

        # Start trading
        await sdk.start_trading_system()
        ```
    """

    def __init__(self, config: SDKConfig):
        """
        Initialize the Neural SDK.

        Args:
            config: SDK configuration object

        Raises:
            ConfigurationError: If configuration is invalid
        """
        self.config = config
        self._validate_config()

        # Core components (to be initialized)
        self._agents = {}
        self._strategies = {}
        self._data_sources = {}
        self._websocket = None
        self._is_running = False

        # Event handlers
        self._market_data_handlers: List[Callable] = []
        self._signal_handlers: List[Callable] = []
        self._trade_handlers: List[Callable] = []

        logger.info(f"Neural SDK initialized for {config.environment} environment")

    def _validate_config(self):
        """Validate SDK configuration."""
        if not self.config.api_key_id and self.config.environment != "development":
            raise ConfigurationError(
                "API key required for non-development environments"
            )

        if self.config.trading.enable_live_trading and not self.config.api_secret:
            raise ConfigurationError("API secret required for live trading")

    @classmethod
    def from_env(cls, prefix: str = "NEURAL_") -> "NeuralSDK":
        """
        Create SDK instance from environment variables.

        Args:
            prefix: Environment variable prefix

        Returns:
            Configured SDK instance
        """
        config = SDKConfig.from_env(prefix)
        return cls(config)

    @classmethod
    def from_config_file(cls, file_path: str) -> "NeuralSDK":
        """
        Create SDK instance from configuration file.

        Args:
            file_path: Path to YAML configuration file

        Returns:
            Configured SDK instance
        """
        config = SDKConfig.from_file(file_path)
        return cls(config)

    def create_signal(
        self,
        action: str,
        market_ticker: str,
        side: str = "YES",
        confidence: float = 0.5,
        quantity: Optional[int] = None,
        price_limit: Optional[float] = None,
        reason: Optional[str] = None,
        **metadata,
    ) -> TradingSignal:
        """
        Create a trading signal.

        Args:
            action: Trading action ("BUY", "SELL", "HOLD")
            market_ticker: Market ticker symbol
            side: Market side ("YES" or "NO")
            confidence: Signal confidence (0.0 to 1.0)
            quantity: Order quantity
            price_limit: Price limit for the order
            reason: Reason for the signal
            **metadata: Additional metadata

        Returns:
            TradingSignal object
        """
        if quantity is None:
            quantity = self.config.trading.default_quantity

        return TradingSignal(
            action=action,
            market_ticker=market_ticker,
            side=side,
            confidence=confidence,
            quantity=quantity,
            price_limit=price_limit,
            reason=reason,
            metadata=metadata or {},
        )

    def strategy(self, func: Callable) -> Callable:
        """
        Decorator to register a trading strategy.

        Args:
            func: Strategy function that takes market data and returns signals

        Returns:
            Decorated strategy function

        Example:
            ```python
            @sdk.strategy
            async def arbitrage_strategy(market_data):
                if market_data.yes_price + market_data.no_price < 0.98:
                    return sdk.create_signal("BUY", market_data.ticker)
            ```
        """
        strategy_name = func.__name__
        self._strategies[strategy_name] = func

        logger.info(f"Registered strategy: {strategy_name}")
        return func

    def on_market_data(self, func: Callable) -> Callable:
        """
        Decorator to register market data handler.

        Args:
            func: Handler function that processes market data

        Returns:
            Decorated handler function
        """
        self._market_data_handlers.append(func)
        return func

    def on_signal(self, func: Callable) -> Callable:
        """
        Decorator to register signal handler.

        Args:
            func: Handler function that processes trading signals

        Returns:
            Decorated handler function
        """
        self._signal_handlers.append(func)
        return func

    def on_trade(self, func: Callable) -> Callable:
        """
        Decorator to register trade handler.

        Args:
            func: Handler function that processes trade results

        Returns:
            Decorated handler function
        """
        self._trade_handlers.append(func)
        return func

    async def start_trading_system(self) -> None:
        """
        Start the complete trading system.

        This initializes all components:
        - Data sources and streaming
        - Agent orchestration
        - Strategy execution
        - Risk management
        - Monitoring

        Raises:
            SDKError: If system fails to start
        """
        if self._is_running:
            logger.warning("Trading system already running")
            return

        try:
            logger.info("Starting Neural Trading System...")

            # Initialize core components
            await self._initialize_data_sources()
            await self._initialize_agents()
            await self._initialize_monitoring()

            self._is_running = True
            logger.info("✅ Neural Trading System started successfully")

            # Start main event loop
            await self._run_trading_loop()

        except Exception as e:
            logger.error(f"Failed to start trading system: {e}")
            await self.stop_trading_system()
            raise SDKError(f"Failed to start trading system: {e}") from e

    async def stop_trading_system(self) -> None:
        """
        Stop the trading system gracefully.

        This shuts down all components in the correct order.
        """
        if not self._is_running:
            return

        logger.info("Stopping Neural Trading System...")

        try:
            # Stop components in reverse order
            await self._shutdown_monitoring()
            await self._shutdown_agents()
            await self._shutdown_data_sources()

            self._is_running = False
            logger.info("✅ Neural Trading System stopped")

        except Exception as e:
            logger.error(f"Error during shutdown: {e}")
            raise SDKError(f"Error during system shutdown: {e}") from e

    async def _initialize_data_sources(self) -> None:
        """Initialize data sources and streaming."""
        logger.info("Initializing data sources...")

        # Initialize Redis connection for pub/sub
        # Initialize market data streams
        # Initialize ESPN data streams
        # Initialize other data sources based on config

        logger.info("✅ Data sources initialized")

    async def _initialize_agents(self) -> None:
        """Initialize and start agents."""
        logger.info("Initializing agents...")

        # TODO: Initialize trading agents if using agent-based architecture
        # This is optional - the SDK can work without agents using just strategies
        # 
        # Example agent initialization:
        # self._agents['data_coordinator'] = DataCoordinatorAgent(self.config)
        # self._agents['portfolio_monitor'] = PortfolioMonitorAgent(self.config)
        # self._agents['risk_manager'] = RiskManagerAgent(self.config)
        # 
        # for name, agent in self._agents.items():
        #     await agent.start()
        #     logger.info(f"Started {name} agent")

        logger.info("✅ Agents initialized (using strategy-based approach)")

    async def _initialize_monitoring(self) -> None:
        """Initialize monitoring and metrics."""
        if self.config.enable_monitoring:
            logger.info("Initializing monitoring...")

            # Initialize metrics collection
            # Initialize health checks
            # Initialize logging

            logger.info("✅ Monitoring initialized")

    async def _shutdown_data_sources(self) -> None:
        """Shutdown data sources."""
        logger.info("Shutting down data sources...")

        # Close all data source connections
        # Stop streaming threads/tasks

        logger.info("✅ Data sources shut down")

    async def _shutdown_agents(self) -> None:
        """Shutdown agents."""
        logger.info("Shutting down agents...")

        # Stop all agents
        # Close agent connections

        logger.info("✅ Agents shut down")

    async def _shutdown_monitoring(self) -> None:
        """Shutdown monitoring."""
        if self.config.enable_monitoring:
            logger.info("Shutting down monitoring...")

            # Stop metrics collection
            # Close monitoring connections

            logger.info("✅ Monitoring shut down")

    async def _run_trading_loop(self) -> None:
        """Main trading system event loop."""
        logger.info("Starting trading event loop...")

        try:
            while self._is_running:
                # Process market data
                await self._process_market_data()

                # Execute strategies
                await self._execute_strategies()

                # Process signals
                await self._process_signals()

                # Monitor portfolio
                await self._monitor_portfolio()

                # Brief pause to prevent busy waiting
                await asyncio.sleep(0.1)

        except asyncio.CancelledError:
            logger.info("Trading loop cancelled")
            raise
        except Exception as e:
            logger.error(f"Error in trading loop: {e}")
            raise

    async def _process_market_data(self) -> None:
        """Process incoming market data."""
        # Get market data from sources
        # Call market data handlers
        # Update internal market data cache

        for handler in self._market_data_handlers:
            try:
                # Call handler with market data
                pass
            except Exception as e:
                logger.error(f"Error in market data handler: {e}")

    async def _execute_strategies(self) -> None:
        """Execute registered trading strategies."""
        # Get current market data
        # Execute each strategy
        # Collect generated signals

        for strategy_name, strategy_func in self._strategies.items():
            try:
                # Execute strategy and collect signals
                pass
            except Exception as e:
                logger.error(f"Error executing strategy {strategy_name}: {e}")

    async def _process_signals(self) -> None:
        """Process trading signals."""
        # Validate signals
        # Apply risk management
        # Execute trades if approved
        # Call signal handlers

        for handler in self._signal_handlers:
            try:
                # Call handler with signals
                pass
            except Exception as e:
                logger.error(f"Error in signal handler: {e}")

    async def _monitor_portfolio(self) -> None:
        """Monitor portfolio and risk metrics."""
        # Update portfolio positions
        # Check risk limits
        # Generate risk alerts if needed
        # Update performance metrics

        pass

    async def get_market_data(self, ticker: str) -> Optional[MarketData]:
        """
        Get current market data for a specific ticker.

        Args:
            ticker: Market ticker symbol

        Returns:
            MarketData object or None if not found
        """
        # TODO: Implement market data fetching from data sources
        # This should query the unified stream manager or Kalshi client
        # Example implementation:
        # if self.stream_manager:
        #     return await self.stream_manager.get_market_context(ticker)
        # return None
        return None  # Placeholder - implement in your integration

    async def execute_signal(self, signal: TradingSignal) -> TradeResult:
        """
        Execute a trading signal.

        Args:
            signal: Trading signal to execute

        Returns:
            TradeResult with execution details

        Raises:
            TradingError: If trade execution fails
        """
        # TODO: Implement trade execution
        # This should:
        # 1. Validate signal against risk limits
        # 2. Check available capital
        # 3. Execute trade via Kalshi API
        # 4. Return TradeResult with execution details
        #
        # Example implementation:
        # if self.config.trading.enable_paper_trading:
        #     return await self._execute_paper_trade(signal)
        # else:
        #     return await self._execute_live_trade(signal)
        
        raise NotImplementedError("Trade execution not yet implemented - override in your implementation")

    async def get_balance(self) -> float:
        """
        Get current account balance.

        Returns:
            Available cash balance in dollars

        Raises:
            SDKError: If balance retrieval fails

        Example:
            ```python
            sdk = NeuralSDK.from_env()
            balance = await sdk.get_balance()
            print(f"Available balance: ${balance:.2f}")
            ```
        """
        try:
            from ..data_pipeline.data_sources.kalshi.client import KalshiClient
            client = KalshiClient()
            
            try:
                balance_response = client.get('/balance')
                balance = balance_response.get('balance', 0) / 100  # Convert cents to dollars
                return balance
            finally:
                client.close()
                
        except Exception as e:
            logger.error(f"Failed to get balance: {e}")
            raise SDKError(f"Balance retrieval failed: {e}") from e

    async def get_positions(self) -> List[Position]:
        """
        Get current portfolio positions.

        Returns:
            List of Position objects representing current holdings

        Raises:
            SDKError: If position retrieval fails

        Example:
            ```python
            sdk = NeuralSDK.from_env()
            positions = await sdk.get_positions()
            
            for position in positions:
                print(f"{position.market_name}: {position.position} shares")
            ```
        """
        try:
            from ..data_pipeline.data_sources.kalshi.client import KalshiClient
            from dateutil.parser import parse as parse_datetime
            
            client = KalshiClient()
            
            try:
                positions_response = client.get('/portfolio/positions')
                market_positions = positions_response.get('market_positions', [])
                
                positions = []
                for pos_data in market_positions:
                    # Parse last updated timestamp
                    last_updated = None
                    if pos_data.get('last_updated_ts'):
                        try:
                            last_updated = parse_datetime(pos_data['last_updated_ts'])
                        except:
                            pass
                    
                    position = Position(
                        ticker=pos_data.get('ticker', ''),
                        position=pos_data.get('position', 0),
                        market_exposure=pos_data.get('market_exposure', 0) / 100,  # Convert cents to dollars
                        total_traded=pos_data.get('total_traded', 0) / 100,
                        realized_pnl=pos_data.get('realized_pnl', 0) / 100,
                        fees_paid=pos_data.get('fees_paid', 0) / 100,
                        resting_orders_count=pos_data.get('resting_orders_count', 0),
                        last_updated=last_updated
                    )
                    positions.append(position)
                
                return positions
                
            finally:
                client.close()
                
        except Exception as e:
            logger.error(f"Failed to get positions: {e}")
            raise SDKError(f"Position retrieval failed: {e}") from e

    async def get_orders(self, limit: int = 50, status: str = 'all') -> List[Order]:
        """
        Get recent orders.

        Args:
            limit: Maximum number of orders to return
            status: Filter by order status ('all', 'pending', 'filled', 'cancelled')

        Returns:
            List of Order objects

        Raises:
            SDKError: If order retrieval fails

        Example:
            ```python
            sdk = NeuralSDK.from_env()
            
            # Get all recent orders
            orders = await sdk.get_orders(limit=10)
            
            # Get only pending orders
            pending = await sdk.get_orders(status='pending')
            ```
        """
        try:
            from ..data_pipeline.data_sources.kalshi.client import KalshiClient
            from dateutil.parser import parse as parse_datetime
            
            client = KalshiClient()
            
            try:
                params = {'limit': limit}
                if status != 'all':
                    params['status'] = status
                    
                # Try different order endpoints
                orders_response = None
                for endpoint in ['/orders', '/portfolio/orders']:
                    try:
                        orders_response = client.get(endpoint, params=params)
                        break
                    except:
                        continue
                
                if not orders_response:
                    return []
                
                order_data_list = orders_response.get('orders', [])
                orders = []
                
                for order_data in order_data_list:
                    # Parse created time
                    created_time = datetime.utcnow()
                    if order_data.get('created_time'):
                        try:
                            created_time = parse_datetime(order_data['created_time'])
                        except:
                            pass
                    
                    order = Order(
                        order_id=order_data.get('order_id', ''),
                        market_ticker=order_data.get('market_ticker', ''),
                        side=order_data.get('side', 'YES'),
                        action=order_data.get('action', 'BUY'),
                        quantity=order_data.get('count', order_data.get('quantity', 0)),
                        price=order_data.get('price', 0) / 100,  # Convert cents to dollars
                        status=order_data.get('status', 'UNKNOWN').upper(),
                        created_time=created_time,
                        filled_quantity=order_data.get('filled_count', order_data.get('filled_quantity', 0)),
                        remaining_quantity=order_data.get('remaining_count'),
                        fees=order_data.get('fees', 0) / 100 if order_data.get('fees') else None,
                    )
                    orders.append(order)
                
                return orders
                
            finally:
                client.close()
                
        except Exception as e:
            logger.error(f"Failed to get orders: {e}")
            raise SDKError(f"Order retrieval failed: {e}") from e

    async def place_order(
        self,
        ticker: str,
        side: str,
        quantity: int,
        price: float,
        action: str = "BUY",
        order_type: str = "limit"
    ) -> Order:
        """
        Place a new order.

        Args:
            ticker: Market ticker symbol
            side: Market side ("YES" or "NO")
            quantity: Number of shares to trade
            price: Price per share in dollars
            action: Trade action ("BUY" or "SELL")
            order_type: Order type ("limit" or "market")

        Returns:
            Order object representing the placed order

        Raises:
            SDKError: If order placement fails
            ValidationError: If order parameters are invalid

        Example:
            ```python
            sdk = NeuralSDK.from_env()
            
            # Buy 10 YES shares at $0.65
            order = await sdk.place_order(
                ticker="KXNFLGAME-25SEP04DALPHI-PHI",
                side="YES",
                quantity=10,
                price=0.65
            )
            
            print(f"Order placed: {order.order_id}")
            ```
        """
        # Validate parameters
        if side not in ["YES", "NO"]:
            raise ValidationError(f"Invalid side: {side}. Must be YES or NO")
        if action not in ["BUY", "SELL"]:
            raise ValidationError(f"Invalid action: {action}. Must be BUY or SELL")
        if quantity <= 0:
            raise ValidationError(f"Invalid quantity: {quantity}. Must be positive")
        if price <= 0 or price >= 1:
            raise ValidationError(f"Invalid price: {price}. Must be between 0 and 1")

        try:
            from ..data_pipeline.data_sources.kalshi.client import KalshiClient
            from dateutil.parser import parse as parse_datetime
            
            client = KalshiClient()
            
            try:
                # Prepare order data
                order_data = {
                    "ticker": ticker,
                    "client_order_id": f"neural_sdk_{int(datetime.utcnow().timestamp())}",
                    "side": side,
                    "action": action.lower(),
                    "count": quantity,
                    "type": order_type,
                }
                
                # Add price for limit orders
                if order_type == "limit":
                    order_data["yes_price"] = int(price * 100)  # Convert to cents
                
                # Place order via API
                response = client.post('/orders', json_data=order_data)
                
                # Parse response into Order object
                order = Order(
                    order_id=response.get('order_id', ''),
                    market_ticker=ticker,
                    side=side,
                    action=action,
                    quantity=quantity,
                    price=price,
                    status=response.get('status', 'PENDING').upper(),
                    created_time=datetime.utcnow(),
                    filled_quantity=response.get('filled_count', 0),
                    remaining_quantity=response.get('remaining_count', quantity)
                )
                
                logger.info(f"✅ Order placed: {order.order_id} - {action} {quantity} {side} {ticker} @ ${price:.2f}")
                return order
                
            finally:
                client.close()
                
        except Exception as e:
            logger.error(f"Failed to place order: {e}")
            raise SDKError(f"Order placement failed: {e}") from e

    async def get_portfolio_summary(self) -> Portfolio:
        """
        Get comprehensive portfolio summary.

        Returns:
            Portfolio object with complete portfolio information

        Raises:
            SDKError: If portfolio data retrieval fails

        Example:
            ```python
            sdk = NeuralSDK.from_env()
            portfolio = await sdk.get_portfolio_summary()
            
            print(f"Balance: ${portfolio.balance:.2f}")
            print(f"Total Exposure: ${portfolio.total_exposure:.2f}")
            print(f"Positions: {portfolio.position_count}")
            ```
        """
        try:
            # Get all portfolio data concurrently
            balance_task = self.get_balance()
            positions_task = self.get_positions()
            orders_task = self.get_orders(status='pending')
            
            balance, positions, active_orders = await asyncio.gather(
                balance_task, positions_task, orders_task, return_exceptions=True
            )
            
            # Handle any exceptions
            if isinstance(balance, Exception):
                balance = 0.0
            if isinstance(positions, Exception):
                positions = []
            if isinstance(active_orders, Exception):
                active_orders = []
            
            # Calculate totals
            total_exposure = sum(pos.market_exposure for pos in positions)
            total_fees = sum(pos.fees_paid for pos in positions)
            total_pnl = sum(pos.realized_pnl for pos in positions)
            
            portfolio = Portfolio(
                balance=balance,
                total_value=balance + total_exposure,  # Simplified calculation
                positions=positions,
                daily_pnl=0.0,  # Would need historical data to calculate
                total_pnl=total_pnl,
                total_fees_paid=total_fees,
                active_orders=len(active_orders),
                last_updated=datetime.utcnow()
            )
            
            return portfolio
            
        except Exception as e:
            logger.error(f"Failed to get portfolio summary: {e}")
            raise SDKError(f"Portfolio summary retrieval failed: {e}") from e

    async def get_portfolio_status(self) -> Dict[str, Any]:
        """
        Get current portfolio status and metrics (legacy method).

        Returns:
            Dictionary with portfolio information

        Note:
            This method is deprecated. Use get_portfolio_summary() instead.
        """
        try:
            portfolio = await self.get_portfolio_summary()
            return {
                "total_value": portfolio.total_value,
                "cash_balance": portfolio.balance,
                "positions": [
                    {
                        "ticker": pos.ticker,
                        "market_name": pos.market_name,
                        "position": pos.position,
                        "exposure": pos.market_exposure,
                        "pnl": pos.realized_pnl
                    }
                    for pos in portfolio.positions
                ],
                "daily_pnl": portfolio.daily_pnl,
                "total_pnl": portfolio.total_pnl,
                "risk_metrics": {
                    "total_exposure": portfolio.total_exposure,
                    "position_count": portfolio.position_count,
                    "largest_position_exposure": portfolio.largest_position.market_exposure if portfolio.largest_position else 0,
                    "total_fees_paid": portfolio.total_fees_paid
                },
            }
        except Exception:
            return {
                "total_value": 0.0,
                "cash_balance": 0.0,
                "positions": [],
                "daily_pnl": 0.0,
                "total_pnl": 0.0,
                "risk_metrics": {},
            }

    def get_system_status(self) -> Dict[str, Any]:
        """
        Get overall system status.

        Returns:
            Dictionary with system status information
        """
        return {
            "is_running": self._is_running,
            "environment": self.config.environment,
            "data_sources_connected": len(self._data_sources),
            "agents_active": len(self._agents),
            "strategies_loaded": len(self._strategies),
            "last_update": datetime.utcnow().isoformat(),
        }

    async def health_check(self) -> Dict[str, Any]:
        """
        Perform comprehensive health check.

        Returns:
            Dictionary with health check results
        """
        health = {
            "overall": "healthy",
            "components": {},
            "timestamp": datetime.utcnow().isoformat(),
        }

        # Check data sources
        health["components"]["data_sources"] = "healthy"  # Placeholder

        # Check agents
        health["components"]["agents"] = "healthy"  # Placeholder

        # Check trading
        health["components"]["trading"] = "healthy"  # Placeholder

        # Determine overall health
        component_statuses = health["components"].values()
        if "unhealthy" in component_statuses:
            health["overall"] = "unhealthy"
        elif "degraded" in component_statuses:
            health["overall"] = "degraded"

        return health

    # WebSocket Methods
    
    def create_websocket(self):
        """
        Create a WebSocket client for real-time market data streaming.
        
        Returns:
            NeuralWebSocket: WebSocket client instance
            
        Example:
            ```python
            sdk = NeuralSDK.from_env()
            websocket = sdk.create_websocket()
            
            @websocket.on_market_data
            async def handle_price_update(market_data):
                print(f"Price: {market_data['yes_price']}")
            
            await websocket.connect()
            await websocket.subscribe_markets(['NFL-*'])
            ```
        """
        from ..streaming.websocket import NeuralWebSocket
        return NeuralWebSocket(self.config)
    
    def create_nfl_stream(self):
        """
        Create an NFL-specific market stream.
        
        Returns:
            NFLMarketStream: NFL market streaming client
            
        Example:
            ```python
            sdk = NeuralSDK.from_env()
            nfl_stream = sdk.create_nfl_stream()
            
            await nfl_stream.connect()
            await nfl_stream.subscribe_to_game("25SEP04DALPHI")
            
            game_summary = nfl_stream.get_game_summary("25SEP04DALPHI")
            print(f"Win probability: {game_summary['win_probability']}")
            ```
        """
        from ..streaming.market_stream import NFLMarketStream
        return NFLMarketStream(self.config)
    
    async def start_streaming(self, markets: List[str] = None):
        """
        Start WebSocket streaming for specified markets.
        
        This is a convenience method that creates a WebSocket,
        connects, and subscribes to markets in one call.
        
        Args:
            markets: List of market tickers to subscribe to
            
        Example:
            ```python
            sdk = NeuralSDK.from_env()
            
            @sdk.on_market_data
            async def handle_updates(market_data):
                print(f"Update: {market_data}")
            
            await sdk.start_streaming(['NFL-*'])
            ```
        """
        if self._websocket is None:
            self._websocket = self.create_websocket()
            
            # Connect SDK handlers to WebSocket
            for handler in self._market_data_handlers:
                self._websocket.on_market_data(handler)
            
            for handler in self._trade_handlers:
                self._websocket.on_trade(handler)
        
        await self._websocket.connect()
        
        if markets:
            await self._websocket.subscribe_markets(markets)
        
        logger.info("✅ Neural SDK streaming started")
    
    async def stop_streaming(self):
        """Stop WebSocket streaming."""
        if self._websocket:
            await self._websocket.disconnect()
            self._websocket = None
            logger.info("Neural SDK streaming stopped")
    
    def on_market_update(self, func: Callable) -> Callable:
        """
        Decorator to register market data update handler.
        
        This is an alias for on_market_data for WebSocket events.
        
        Args:
            func: Handler function that processes market data updates
            
        Returns:
            Decorated handler function
        """
        return self.on_market_data(func)
    
    def __repr__(self) -> str:
        """String representation of the SDK."""
        return f"NeuralSDK(environment={self.config.environment}, running={self._is_running})"
