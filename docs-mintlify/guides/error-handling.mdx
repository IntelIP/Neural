---
title: 'Error Handling'
description: 'Handle errors and exceptions gracefully in Neural SDK applications'
---

## Overview

Robust error handling is crucial for production trading systems. Neural SDK provides comprehensive error handling mechanisms to help you build resilient applications that can recover from network issues, API errors, and other failures.

## Error Types

<CardGroup cols={2}>
  <Card title="Network Errors" icon="wifi-slash">
    Connection timeouts, DNS failures, SSL errors
  </Card>
  <Card title="API Errors" icon="exclamation-triangle">
    Authentication, rate limiting, invalid requests
  </Card>
  <Card title="Market Errors" icon="chart-line-down">
    Market closed, insufficient funds, invalid orders
  </Card>
  <Card title="Data Errors" icon="database">
    Missing data, malformed responses, parsing errors
  </Card>
</CardGroup>

## Basic Error Handling

### Try-Catch Pattern

```python
from neural_sdk import NeuralSDK
from neural_sdk.exceptions import (
    NeuralSDKError, 
    AuthenticationError,
    NetworkError, 
    MarketError
)

async def basic_error_handling():
    sdk = NeuralSDK.from_env()
    
    try:
        # Attempt to get markets
        markets = await sdk.get_markets()
        print(f"Found {len(markets)} markets")
        
    except AuthenticationError as e:
        print(f"‚ùå Authentication failed: {e}")
        # Handle authentication issues
        await handle_auth_error(e)
        
    except NetworkError as e:
        print(f"üåê Network error: {e}")
        # Handle network issues
        await handle_network_error(e)
        
    except MarketError as e:
        print(f"üìà Market error: {e}")
        # Handle market-specific issues
        await handle_market_error(e)
        
    except NeuralSDKError as e:
        print(f"üîß SDK error: {e}")
        # Handle general SDK errors
        await handle_general_error(e)
        
    except Exception as e:
        print(f"üí• Unexpected error: {e}")
        # Handle unexpected errors
        await handle_unexpected_error(e)
```

### Retry Logic

```python
import asyncio
from functools import wraps

def retry_on_error(max_retries=3, delay=1.0, backoff=2.0):
    """Decorator for automatic retry with exponential backoff"""
    
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                    
                except (NetworkError, ConnectionError) as e:
                    last_exception = e
                    
                    if attempt == max_retries:
                        raise last_exception
                    
                    wait_time = delay * (backoff ** attempt)
                    print(f"Attempt {attempt + 1} failed, retrying in {wait_time:.1f}s...")
                    await asyncio.sleep(wait_time)
                    
                except Exception as e:
                    # Don't retry on non-network errors
                    raise e
            
            raise last_exception
        
        return wrapper
    return decorator

# Usage
@retry_on_error(max_retries=3, delay=2.0)
async def get_markets_with_retry():
    sdk = NeuralSDK.from_env()
    return await sdk.get_markets()
```

## WebSocket Error Handling

### Robust WebSocket Connection

```python
from neural_sdk.streaming import NeuralWebSocket
from neural_sdk.exceptions import WebSocketError, ConnectionLostError

class RobustWebSocketHandler:
    def __init__(self):
        self.sdk = NeuralSDK.from_env()
        self.websocket = None
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.is_running = False
        
    async def start(self):
        """Start WebSocket connection with error handling"""
        self.is_running = True
        
        while self.is_running:
            try:
                await self._connect()
                await self._listen()
                
            except ConnectionLostError as e:
                print(f"Connection lost: {e}")
                await self._handle_connection_lost()
                
            except WebSocketError as e:
                print(f"WebSocket error: {e}")
                await self._handle_websocket_error(e)
                
            except Exception as e:
                print(f"Unexpected error: {e}")
                await self._handle_unexpected_error(e)
    
    async def _connect(self):
        """Establish WebSocket connection"""
        try:
            self.websocket = self.sdk.create_websocket()
            await self.websocket.connect()
            print("‚úÖ WebSocket connected")
            self.reconnect_attempts = 0
            
        except Exception as e:
            print(f"‚ùå Failed to connect WebSocket: {e}")
            raise
    
    async def _listen(self):
        """Listen for WebSocket messages"""
        async for message in self.websocket.listen():
            try:
                await self.process_message(message)
                
            except Exception as e:
                print(f"Error processing message: {e}")
                # Continue listening despite processing errors
                continue
    
    async def _handle_connection_lost(self):
        """Handle lost connection"""
        if self.reconnect_attempts < self.max_reconnect_attempts:
            self.reconnect_attempts += 1
            wait_time = min(30, 2 ** self.reconnect_attempts)  # Exponential backoff, max 30s
            
            print(f"Reconnecting in {wait_time}s... (attempt {self.reconnect_attempts})")
            await asyncio.sleep(wait_time)
            
        else:
            print("‚ùå Max reconnection attempts reached, stopping")
            self.is_running = False
    
    async def process_message(self, message):
        """Process incoming WebSocket message"""
        try:
            # Your message processing logic here
            print(f"Received: {message}")
            
        except KeyError as e:
            print(f"Missing field in message: {e}")
            
        except ValueError as e:
            print(f"Invalid message format: {e}")
            
        except Exception as e:
            print(f"Error processing message: {e}")
            raise  # Re-raise to be handled by caller

# Usage
handler = RobustWebSocketHandler()
await handler.start()
```

### Circuit Breaker Pattern

```python
import time
from enum import Enum

class CircuitState(Enum):
    CLOSED = "closed"      # Normal operation
    OPEN = "open"          # Failing, blocking requests
    HALF_OPEN = "half_open" # Testing if service recovered

class CircuitBreaker:
    def __init__(self, failure_threshold=5, recovery_timeout=60, expected_exception=Exception):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception
        
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
    
    async def call(self, func, *args, **kwargs):
        """Execute function with circuit breaker protection"""
        
        if self.state == CircuitState.OPEN:
            if self._should_attempt_reset():
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = await func(*args, **kwargs)
            self._on_success()
            return result
            
        except self.expected_exception as e:
            self._on_failure()
            raise e
    
    def _should_attempt_reset(self):
        """Check if enough time has passed to attempt reset"""
        return (time.time() - self.last_failure_time) >= self.recovery_timeout
    
    def _on_success(self):
        """Handle successful call"""
        self.failure_count = 0
        self.state = CircuitState.CLOSED
    
    def _on_failure(self):
        """Handle failed call"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN

# Usage with WebSocket
websocket_breaker = CircuitBreaker(
    failure_threshold=3,
    recovery_timeout=30,
    expected_exception=(NetworkError, WebSocketError)
)

async def protected_websocket_call():
    return await websocket_breaker.call(websocket.get_markets)
```

## Trading Error Handling

### Order Placement Errors

```python
from neural_sdk.exceptions import InsufficientFundsError, MarketClosedError, InvalidOrderError

async def safe_order_placement(sdk, order_details):
    """Safely place orders with comprehensive error handling"""
    
    try:
        # Validate order before placement
        await validate_order(order_details)
        
        # Place the order
        result = await sdk.place_order(
            market_id=order_details['market_id'],
            action=order_details['action'],
            size=order_details['size'],
            price=order_details.get('price')
        )
        
        print(f"‚úÖ Order placed successfully: {result.order_id}")
        return result
        
    except InsufficientFundsError as e:
        print(f"üí∞ Insufficient funds: {e}")
        # Try with smaller position size
        reduced_size = order_details['size'] * 0.5
        if reduced_size >= 1:  # Minimum order size
            order_details['size'] = reduced_size
            return await safe_order_placement(sdk, order_details)
        else:
            print("‚ùå Cannot reduce order size further")
            return None
            
    except MarketClosedError as e:
        print(f"üö´ Market closed: {e}")
        # Queue order for when market reopens
        await queue_order_for_market_open(order_details)
        return None
        
    except InvalidOrderError as e:
        print(f"üìù Invalid order: {e}")
        # Attempt to fix common order issues
        fixed_order = await attempt_order_fix(order_details, e)
        if fixed_order:
            return await safe_order_placement(sdk, fixed_order)
        return None
        
    except Exception as e:
        print(f"üí• Unexpected order error: {e}")
        # Log error and return None
        await log_error("order_placement", e, order_details)
        return None

async def validate_order(order_details):
    """Validate order details before placement"""
    required_fields = ['market_id', 'action', 'size']
    
    for field in required_fields:
        if field not in order_details:
            raise InvalidOrderError(f"Missing required field: {field}")
    
    if order_details['size'] <= 0:
        raise InvalidOrderError("Order size must be positive")
    
    if order_details['action'] not in ['BUY', 'SELL']:
        raise InvalidOrderError("Action must be BUY or SELL")

async def attempt_order_fix(order_details, error):
    """Attempt to fix common order issues"""
    error_msg = str(error).lower()
    
    # Fix common price issues
    if "price" in error_msg:
        # Remove price for market order
        if "price" in order_details:
            del order_details["price"]
            return order_details
    
    # Fix size issues
    if "size" in error_msg or "minimum" in error_msg:
        # Round to minimum increment
        order_details['size'] = max(1, int(order_details['size']))
        return order_details
    
    return None
```

### Position Management Errors

```python
from neural_sdk.exceptions import PositionNotFoundError, ExcessiveRiskError

class SafePositionManager:
    def __init__(self, sdk, risk_limits):
        self.sdk = sdk
        self.risk_limits = risk_limits
        
    async def close_position(self, market_id, reason="manual"):
        """Safely close position with error handling"""
        
        try:
            # Get current position
            position = await self.sdk.get_position(market_id)
            
            if position.size == 0:
                print(f"No position to close for {market_id}")
                return True
            
            # Close the position
            result = await self.sdk.close_position(market_id)
            print(f"‚úÖ Closed position: {result}")
            return True
            
        except PositionNotFoundError:
            print(f"Position not found for {market_id}")
            return True  # Already closed
            
        except MarketClosedError:
            print(f"Market closed, position will close at settlement")
            return False
            
        except Exception as e:
            print(f"Error closing position: {e}")
            # Try partial close
            try:
                await self._attempt_partial_close(market_id)
                return True
            except Exception as partial_error:
                print(f"Partial close also failed: {partial_error}")
                return False
    
    async def _attempt_partial_close(self, market_id):
        """Attempt to partially close position if full close fails"""
        position = await self.sdk.get_position(market_id)
        partial_size = position.size * 0.5  # Close 50%
        
        return await self.sdk.close_position(market_id, size=partial_size)
    
    async def check_risk_limits(self):
        """Monitor and enforce risk limits"""
        try:
            portfolio = await self.sdk.get_portfolio()
            
            # Check total exposure
            if portfolio.total_exposure > self.risk_limits['max_exposure']:
                print("üö® Risk limit exceeded - reducing positions")
                await self._reduce_positions()
            
            # Check individual position sizes
            for position in portfolio.positions:
                if position.size > self.risk_limits['max_position_size']:
                    print(f"üö® Position too large: {position.market_id}")
                    await self._reduce_position(position.market_id)
            
        except Exception as e:
            print(f"Error checking risk limits: {e}")
    
    async def _reduce_positions(self):
        """Reduce positions to meet risk limits"""
        try:
            positions = await self.sdk.get_positions()
            
            # Close positions starting with least profitable
            sorted_positions = sorted(positions, key=lambda p: p.unrealized_pnl)
            
            for position in sorted_positions:
                if await self.close_position(position.market_id, "risk_management"):
                    # Check if we're now within limits
                    portfolio = await self.sdk.get_portfolio()
                    if portfolio.total_exposure <= self.risk_limits['max_exposure']:
                        break
                        
        except Exception as e:
            print(f"Error reducing positions: {e}")
```

## Logging and Monitoring

### Comprehensive Logging

```python
import logging
import json
from datetime import datetime

class TradingLogger:
    def __init__(self, log_level=logging.INFO):
        self.logger = logging.getLogger('neural_sdk')
        self.logger.setLevel(log_level)
        
        # Create handlers
        file_handler = logging.FileHandler('neural_trading.log')
        console_handler = logging.StreamHandler()
        
        # Create formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
    
    def log_error(self, operation, error, context=None):
        """Log error with context"""
        error_data = {
            'timestamp': datetime.now().isoformat(),
            'operation': operation,
            'error_type': type(error).__name__,
            'error_message': str(error),
            'context': context
        }
        
        self.logger.error(json.dumps(error_data))
    
    def log_trade(self, trade_data):
        """Log trade execution"""
        self.logger.info(f"Trade executed: {json.dumps(trade_data)}")
    
    def log_connection_event(self, event_type, details):
        """Log connection events"""
        event_data = {
            'timestamp': datetime.now().isoformat(),
            'event_type': event_type,
            'details': details
        }
        
        self.logger.info(f"Connection event: {json.dumps(event_data)}")

# Global logger instance
trading_logger = TradingLogger()
```

### Health Monitoring

```python
from neural_sdk.monitoring import HealthMonitor
import asyncio

class SystemHealthMonitor:
    def __init__(self, sdk):
        self.sdk = sdk
        self.health_checks = {
            'api_connection': self._check_api_connection,
            'websocket_connection': self._check_websocket_connection,
            'portfolio_sync': self._check_portfolio_sync,
            'data_freshness': self._check_data_freshness
        }
        self.is_monitoring = False
    
    async def start_monitoring(self, check_interval=60):
        """Start continuous health monitoring"""
        self.is_monitoring = True
        
        while self.is_monitoring:
            health_status = await self.run_health_checks()
            
            if not health_status['overall_healthy']:
                await self._handle_health_issues(health_status)
            
            await asyncio.sleep(check_interval)
    
    async def run_health_checks(self):
        """Run all health checks"""
        results = {'timestamp': datetime.now().isoformat()}
        
        for check_name, check_func in self.health_checks.items():
            try:
                results[check_name] = await check_func()
            except Exception as e:
                results[check_name] = {
                    'healthy': False,
                    'error': str(e)
                }
        
        results['overall_healthy'] = all(
            check.get('healthy', False) 
            for check in results.values() 
            if isinstance(check, dict)
        )
        
        return results
    
    async def _check_api_connection(self):
        """Check API connection health"""
        try:
            start_time = time.time()
            await self.sdk.get_markets(limit=1)
            response_time = time.time() - start_time
            
            return {
                'healthy': True,
                'response_time': response_time,
                'status': 'connected'
            }
        except Exception as e:
            return {
                'healthy': False,
                'error': str(e),
                'status': 'disconnected'
            }
    
    async def _check_websocket_connection(self):
        """Check WebSocket connection health"""
        try:
            # Check if WebSocket is connected and receiving data
            websocket = getattr(self, 'websocket', None)
            
            if not websocket or not websocket.is_connected():
                return {
                    'healthy': False,
                    'status': 'disconnected',
                    'error': 'WebSocket not connected'
                }
            
            return {
                'healthy': True,
                'status': 'connected',
                'last_message': websocket.last_message_time
            }
            
        except Exception as e:
            return {
                'healthy': False,
                'error': str(e),
                'status': 'error'
            }
    
    async def _handle_health_issues(self, health_status):
        """Handle detected health issues"""
        for check_name, result in health_status.items():
            if isinstance(result, dict) and not result.get('healthy'):
                print(f"üö® Health issue detected: {check_name}")
                
                # Attempt automatic recovery
                if check_name == 'websocket_connection':
                    await self._recover_websocket()
                elif check_name == 'api_connection':
                    await self._recover_api_connection()
    
    async def _recover_websocket(self):
        """Attempt to recover WebSocket connection"""
        try:
            if hasattr(self, 'websocket'):
                await self.websocket.reconnect()
        except Exception as e:
            print(f"Failed to recover WebSocket: {e}")
    
    async def _recover_api_connection(self):
        """Attempt to recover API connection"""
        try:
            # Refresh authentication
            await self.sdk.refresh_auth()
        except Exception as e:
            print(f"Failed to recover API connection: {e}")
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Fail Fast" icon="bolt">
    Detect and handle errors as early as possible
  </Card>
  <Card title="Graceful Degradation" icon="arrow-down">
    Continue operating with reduced functionality when possible
  </Card>
  <Card title="Comprehensive Logging" icon="file-text">
    Log all errors with sufficient context for debugging
  </Card>
  <Card title="Monitoring & Alerts" icon="bell">
    Monitor system health and alert on issues
  </Card>
</CardGroup>

## Error Recovery Strategies

<AccordionGroup>
  <Accordion title="Automatic Retry">
    Use exponential backoff for transient network errors
  </Accordion>
  
  <Accordion title="Circuit Breaker">
    Stop attempting operations when service is clearly down
  </Accordion>
  
  <Accordion title="Fallback Options">
    Have alternative data sources or simplified functionality
  </Accordion>
  
  <Accordion title="Manual Intervention">
    Alert operators for issues requiring human intervention
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Monitoring Setup" icon="chart-bar" href="/guides/monitoring">
    Set up comprehensive monitoring and alerting
  </Card>
  <Card title="Risk Management" icon="shield" href="/api-reference/trading/risk-management">
    Implement robust risk management
  </Card>
</CardGroup>